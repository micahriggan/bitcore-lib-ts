'use strict';
import * as _ from 'lodash';
import assert from 'assert';
import { BitcoreLib } from '../src';
import * as Buffer from 'buffer';
const BitcoreError = BitcoreLib.errors;
const ErrorTypes = BitcoreError.Types;
const hdErrors = ErrorTypes.HDPrivateKey;
const buffer = require('buffer');
const Networks = BitcoreLib.Network;
const BufferUtil = BitcoreLib.util.buffer;
const HDPrivateKey = BitcoreLib.HDPrivateKey;
const Base58Check = BitcoreLib.encoding.Base58Check;

const xprivkey =
  'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi';
const json =
  '{"network":"livenet","depth":0,"fingerPrint":876747070,"parentFingerPrint":0,"childIndex":0,"chainCode":"873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508","privateKey":"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35","checksum":-411132559,"xprivkey":"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi"}';
describe('HDPrivate key interface', () => {
  /* jshint maxstatements: 50 */
  const expectFail = (func, error) => {
    let got = null;
    try {
      func();
    } catch (e) {
      got = e instanceof error;
    }
    expect(got).to.equal(true);
  };

  const expectDerivationFail = (argument, error) => {
    return expectFail(() => {
      const privateKey = new HDPrivateKey(xprivkey);
      privateKey.derive(argument);
    }, error);
  };

  const expectFailBuilding = (argument, error) => {
    return expectFail(() => {
      return new HDPrivateKey(argument);
    }, error);
  };

  const expectSeedFail = (argument, error) => {
    return expectFail(() => {
      return HDPrivateKey.fromSeed(argument);
    }, error);
  };

  it('should make a new private key from random', () => {
    should.exist(new HDPrivateKey().xprivkey);
  });

  it('should make a new private key from random for testnet', () => {
    const key = new HDPrivateKey('testnet');
    should.exist(key.xprivkey);
    key.network.name.should.equal('testnet');
  });

  it('should not be able to change read-only properties', () => {
    const hdkey = new HDPrivateKey();
    expect(() => {
      hdkey.fingerPrint = 'notafingerprint';
    }).to.throw(TypeError);
  });

  it('should error with an invalid checksum', () => {
    expectFailBuilding(xprivkey + '1', ErrorTypes.InvalidB58Checksum);
  });

  it('can be rebuilt from a json generated by itself', () => {
    const regenerate = new HDPrivateKey(json);
    regenerate.xprivkey.should.equal(xprivkey);
  });

  it('builds a json keeping the structure and same members', () => {
    assert(
      _.isEqual(
        new HDPrivateKey(json).toJSON(),
        new HDPrivateKey(xprivkey).toJSON()
      )
    );
  });

  describe('instantiation', () => {
    it('invalid argument: can not instantiate from a number', () => {
      expectFailBuilding(1, hdErrors.errors.UnrecognizedArgument);
    });
    it('allows no-new calling', () => {
      HDPrivateKey(xprivkey)
        .toString()
        .should.equal(xprivkey);
    });
    it('allows the use of a copy constructor', () => {
      HDPrivateKey(HDPrivateKey(xprivkey)).xprivkey.should.equal(xprivkey);
    });
  });

  describe('public key', () => {
    const testnetKey = new HDPrivateKey(
      'tprv8ZgxMBicQKsPdEeU2KiGFnUgRGriMnQxrwrg6FWCBg4jeiidHRyCCdA357kfkZiGaXEapWZsGDKikeeEbvgXo3UmEdbEKNdQH9VXESmGuUK'
    );
    const livenetKey = new HDPrivateKey(
      'xprv9s21ZrQH143K3e39bnn1vyS7YFa1EAJAFGDoeHaSBsgBxgAkTEXeSx7xLvhNQNJxJwhzziWcK3znUFKRPRwWBPkKZ8ijUBa5YYpYPQmeBDX'
    );

    it('matches the network', () => {
      testnetKey.publicKey.network.should.equal(Networks.testnet);
      livenetKey.publicKey.network.should.equal(Networks.livenet);
    });

    it('cache for xpubkey works', () => {
      const privateKey = new HDPrivateKey(xprivkey);
      should.not.exist(privateKey._hdPublicKey);
      privateKey.xpubkey.should.equal(privateKey.xpubkey);
      should.exist(privateKey._hdPublicKey);
    });
  });

  it('inspect() displays correctly', () => {
    HDPrivateKey(xprivkey)
      .inspect()
      .should.equal('<HDPrivateKey: ' + xprivkey + '>');
  });
  it('fails when trying to derive with an invalid argument', () => {
    expectDerivationFail([], hdErrors.errors.InvalidDerivationArgument);
  });

  it('catches early invalid paths', () => {
    expectDerivationFail('s', hdErrors.errors.InvalidPath);
  });

  it('allows derivation of hardened keys by passing a very big number', () => {
    const privateKey = new HDPrivateKey(xprivkey);
    const derivedByNumber = privateKey.derive(0x80000000);
    const derivedByArgument = privateKey.derive(0, true);
    derivedByNumber.xprivkey.should.equal(derivedByArgument.xprivkey);
  });

  it("returns itself with 'm' parameter", () => {
    const privateKey = new HDPrivateKey(xprivkey);
    privateKey.should.equal(privateKey.derive('m'));
  });

  it('returns InvalidArgument if invalid data is given to getSerializedError', () => {
    expect(
      HDPrivateKey.getSerializedError(1) ===
        new BitcoreError(hdErrors.errors.UnrecognizedArgument)
    ).to.equal(true);
  });

  it('returns InvalidLength if data of invalid length is given to getSerializedError', () => {
    const b58s = Base58Check.encode(new buffer.Buffer('onestring'));
    expect(
      HDPrivateKey.getSerializedError(b58s) ===
        new BitcoreError(hdErrors.errors.InvalidLength)
    ).to.equal(true);
  });

  it('returns InvalidNetworkArgument if an invalid network is provided', () => {
    expect(
      HDPrivateKey.getSerializedError(xprivkey, 'invalidNetwork') ===
        new BitcoreError(ErrorTypes.InvalidNetworkArgument)
    ).to.equal(true);
  });

  it('recognizes that the wrong network was asked for', () => {
    expect(
      HDPrivateKey.getSerializedError(xprivkey, 'testnet') ===
        new BitcoreError(ErrorTypes.InvalidNetwork)
    ).to.equal(true);
  });

  it('recognizes the correct network', () => {
    expect(HDPrivateKey.getSerializedError(xprivkey, 'livenet')).to.equal(null);
  });

  describe('on creation from seed', () => {
    it('converts correctly from an hexa string', () => {
      should.exist(
        HDPrivateKey.fromSeed('01234567890abcdef01234567890abcdef').xprivkey
      );
    });
    it('fails when argument is not a buffer or string', () => {
      expectSeedFail(1, hdErrors.errors.InvalidEntropyArgument);
    });
    it("fails when argument doesn't provide enough entropy", () => {
      expectSeedFail(
        '01',
        hdErrors.errors.InvalidEntropyArgument.errors.NotEnoughEntropy
      );
    });
    it('fails when argument provides too much entropy', () => {
      let entropy = '0';
      for (let i = 0; i < 129; i++) {
        entropy += '1';
      }
      expectSeedFail(
        entropy,
        hdErrors.errors.InvalidEntropyArgument.errors.TooMuchEntropy
      );
    });
  });

  it('correctly errors if an invalid checksum is provided', () => {
    const privKey = new HDPrivateKey(xprivkey);
    let error = null;
    try {
      const buffers = privKey._buffers;
      buffers.checksum = BufferUtil.integerAsBuffer(0);
      const privateKey = new HDPrivateKey(buffers);
    } catch (e) {
      error = e;
    }
    expect(error === new BitcoreError(ErrorTypes.InvalidB58Checksum)).to.equal(
      true
    );
  });
  it('correctly validates the checksum', () => {
    const privKey = new HDPrivateKey(xprivkey);
    expect(() => {
      const buffers = privKey._buffers;
      return new HDPrivateKey(buffers);
    }).to.not.throw();
  });

  it("shouldn't matter if derivations are made with strings or numbers", () => {
    const privateKey = new HDPrivateKey(xprivkey);
    const derivedByString = privateKey.derive("m/0'/1/2'");
    const derivedByNumber = privateKey
      .derive(0, true)
      .derive(1)
      .derive(2, true);
    derivedByNumber.xprivkey.should.equal(derivedByString.xprivkey);
  });

  describe('validates paths', () => {
    it('validates correct paths', () => {
      let valid;

      valid = HDPrivateKey.isValidPath("m/0'/1/2'");
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath('m');
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(123, true);
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(123);
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(HDPrivateKey.Hardened + 123);
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(HDPrivateKey.Hardened + 123, true);
      valid.should.equal(true);
    });

    const invalid = ['m/-1/12', 'bad path', 'K', 'm/', 'm/12asd', 'm/1/2//3'];

    invalid.forEach(datum => {
      it('rejects illegal path ' + datum, () => {
        HDPrivateKey.isValidPath(datum).should.equal(false);
        expect(HDPrivateKey._getDerivationIndexes(datum)).to.equal(null);
      });
    });

    it('generates deriving indexes correctly', () => {
      let indexes;

      indexes = HDPrivateKey._getDerivationIndexes('m/-1/12');
      expect(indexes).to.equal(null);

      indexes = HDPrivateKey._getDerivationIndexes("m/0/12/12'");
      indexes.should.eql([0, 12, HDPrivateKey.Hardened + 12]);

      indexes = HDPrivateKey._getDerivationIndexes("m/0/12/12'");
      indexes.should.eql([0, 12, HDPrivateKey.Hardened + 12]);
    });
  });

  describe('conversion to/from buffer', () => {
    const str =
      'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi';
    it('should roundtrip to/from a buffer', () => {
      const priv = new HDPrivateKey(str);
      const toBuffer = priv.toBuffer();
      const fromBuffer = HDPrivateKey.fromBuffer(toBuffer);
      const roundTrip = new HDPrivateKey(fromBuffer.toBuffer());
      roundTrip.xprivkey.should.equal(str);
    });
  });

  describe('conversion to plain object/json', () => {
    const plainObject = {
      network: 'livenet',
      depth: 0,
      fingerPrint: 876747070,
      parentFingerPrint: 0,
      childIndex: 0,
      chainCode:
        '873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508',
      privateKey:
        'e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35',
      checksum: -411132559,
      xprivkey:
        'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvN' +
        'KmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi'
    };
    it('toObject leaves no Buffer instances', () => {
      const privKey = new HDPrivateKey(xprivkey);
      const object = privKey.toObject();
      _.each(_.values(object), value => {
        expect(BufferUtil.isBuffer(value)).to.equal(false);
      });
    });
    it('roundtrips toObject', () => {
      expect(
        HDPrivateKey.fromObject(new HDPrivateKey(xprivkey).toObject()).xprivkey
      ).to.equal(xprivkey);
    });
    it('roundtrips to JSON and to Object', () => {
      const privkey = new HDPrivateKey(xprivkey);
      expect(HDPrivateKey.fromObject(privkey.toJSON()).xprivkey).to.equal(
        xprivkey
      );
    });
    it('recovers state from JSON', () => {
      new HDPrivateKey(JSON.stringify(plainObject)).xprivkey.should.equal(
        xprivkey
      );
    });
    it('recovers state from Object', () => {
      new HDPrivateKey(plainObject).xprivkey.should.equal(xprivkey);
    });
  });
});
